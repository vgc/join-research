<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>No join</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.0/dist/svg.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@catsums/vector2@1.2.5/lib/umd/index.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.3.min.js"></script>
    <style>
        body,
        div,
        p,
        h1,
        h2,
        h3 {
            font-family: 'Open Sans', sans-serif;
            margin: 0;
            padding: 0;
        }

        .parameter-input {
            display: inline-block;
        }

        .parameter-label {
            display: inline-block;
        }

        .parameter-input[type=range] {
            width: 100%;
        }

        .join-applet {
            display: flex;
            flex-direction: column;
            row-gap: 8px;
            padding: 8px;
        }

        .parameters {
            display: flex;
            flex-direction: column;
            row-gap: 8px;
        }

        .parameter {
            display: flex;
            margin: 2px 0;
        }

        .parameter p {
            min-width: 16em;
        }

        .parameter-group {
            max-width: 50%;
            background-color: #f4f4f4;
            border-radius: 4px;
            padding: 8px;
            font-size: 11pt;
        }

        .parameter-group .title {
            padding-bottom: 4px;
            font-weight: 600;
        }

        .drawing svg {
            border: solid 1px #888888;
        }
    </style>
</head>

<body>
    <div id="main" class="join-applet">
        <div class="parameters"></div>
        <div class="drawing"></div>
    </div>
</body>


<script>
    // Aliases for catsums's vector2 types
    const Vec2 = VECTOR2.Vector2;
    const Line2 = VECTOR2.Vector2Line;
    const Rect2 = VECTOR2.Rect2;
    const Transform2 = VECTOR2.Transform2;
    Vec2.prototype.isNormalized = Vec2.prototype.isNormalised
    Vec2.DET = function (a, b) { return a.x * b.y - a.y * b.x; }

    // Global parameters.
    let main = document.querySelector('#main');
    let parametersDiv = main.querySelector('.parameters');

    height = 600;
    width = 600;
    edgeLength = 250;
    let joinVertex = new Vec2(0, 0);

    var globalparameterDescriptions = [
        { name: 'inputGeometryFillOpacity', prettyName: 'Fill opacity of input geometry', value: 0.1, type: 'range', min: 0, max: 1, step: 0.01 },
        { name: 'inputGeometryStrokeOpacity', prettyName: 'Stroke opacity of input geometry', value: 0.4, type: 'range', min: 0, max: 1, step: 0.01 },
        { name: 'inputGeometryStrokeWidth', prettyName: 'Stroke width of input geometry', value: 2.6, type: 'range', min: 0, max: 10, step: 0.01 },
    ];
    var globals = {};
    parametersDiv.appendChild(createParameterGroup(globalparameterDescriptions, globals));

    let methodSelectToParamGroupDiv = new Map();
    function createParameterGroup(parameterDescriptions, argumentsDict) {
        let customAttributes = ['isTitle'];
        let groupDiv = document.createElement("div");
        groupDiv.classList.add("parameter-group");
        if (parameterDescriptions.length === 0) {
            groupDiv.hidden = true;
        }
        for (parameterDescription of parameterDescriptions) {
            let paramDiv = document.createElement("div");
            paramDiv.classList.add("parameter");
            groupDiv.appendChild(paramDiv);
            let value = argumentsDict[parameterDescription.name];
            // label
            let label = document.createElement("p");
            label.textContent = parameterDescription.prettyName;
            label.classList.add("parameter-label");
            if (parameterDescription.isTitle) {
                label.classList.add("title");
            }
            paramDiv.appendChild(label);

            if (parameterDescription.methods) {
                //
                // perSlice.intersectCutMethodIndex
                // perSlice.intersectCutMethod[0].param
                // or
                // perSlice.intersectCutMethod.param
                // perSlice.intersectCutMethod.index
                // intersectCutMethod0.param
                //
                // in the algorithm itself we'll call sub-methods
                // params.submethod.function(params.subalgo.parameterValues)
                //
                let selectedMethodIndex = 0;
                if (value === undefined) {
                    selectedMethodIndex = parameterDescription.initialMethodIndex || 0;
                    // make a class ?
                    value = {};
                    argumentsDict[parameterDescription.name] = value;
                    value.selectedMethodIndex = selectedMethodIndex;
                    value.methodsData = []
                    for (methodDescription of parameterDescription.methods) {
                        if (methodDescription instanceof Function) {
                            // automatic description
                            methodDescription = {
                                name: methodDescription.name,
                                function: methodDescription,
                                parameters: [],
                            };
                        } else {
                            if (methodDescription.parameters === undefined) {
                                methodDescription.parameters = [];
                            }
                        }
                        methodArgumentsDict = globals[methodDescription.name];
                        if (methodArgumentsDict === undefined) {
                            methodArgumentsDict = {};
                            globals[methodDescription.name] = methodArgumentsDict;
                        }
                        value.methodsData.push({
                            description: methodDescription,
                            arguments: methodArgumentsDict
                        });
                    }
                } else {
                    selectedMethodIndex = value.selectedMethodIndex;
                }
                selectedMethodData = value.methodsData[selectedMethodIndex];

                // select
                let select = document.createElement("select");
                select.classList.add("parameter-input");
                select.classList.add("method");
                for (let i = 0; i < parameterDescription.methods.length; ++i) {
                    let option = document.createElement("option");
                    method = parameterDescription.methods[i];
                    option.textContent = method.prettyName || method.name;
                    option.value = i;
                    select.append(option);
                }
                select.selectedIndex = selectedMethodIndex;
                paramDiv.append(select);

                // parameters
                childParameterGroup = createParameterGroup(
                    selectedMethodData.description.parameters,
                    selectedMethodData.arguments);
                groupDiv.append(childParameterGroup);
                methodSelectToParamGroupDiv.set(select, childParameterGroup);

                // change event handler
                select.addEventListener(
                    'change',
                    ((argumentsDict, name) => {
                        return (event) => {
                            select = event.target;
                            value = argumentsDict[name];
                            value.selectedMethodIndex = select.value;
                            selectedMethodData = value.methodsData[value.selectedMethodIndex];
                            childParameterGroup = methodSelectToParamGroupDiv.get(select);
                            if (childParameterGroup) {
                                childParameterGroup.remove();
                            }
                            childParameterGroup = createParameterGroup(
                                selectedMethodData.description.parameters,
                                selectedMethodData.arguments);
                            methodSelectToParamGroupDiv.set(select, childParameterGroup);
                            select.parentElement.after(childParameterGroup);
                            childParameterGroup
                            onParameterValueChanged();
                        };
                    })(argumentsDict, parameterDescription.name)
                );
            }
            else if (parameterDescription.type == 'select') {
                let select = document.createElement("select");
                select.classList.add("parameter-input");
                for (let i = 0; i < parameterDescription.options.length; ++i) {
                    let option = document.createElement("option");
                    option.textContent = parameterDescription.options[i].prettyName;
                    option.value = i;
                    select.append(option);
                }

                value = argumentsDict[parameterDescription.name];
                if (value === undefined) {
                    value = parameterDescription.initialMethodIndex || 0;
                    argumentsDict[parameterDescription.name] = value;
                }
                select.selectedIndex = value;

                paramDiv.append(select);
                select.addEventListener(
                    'change',
                    ((argumentsDict, name, callback) => {
                        return (event) => {
                            value = event.target.value;
                            if (callback) {
                                callback(value);
                            }
                            argumentsDict[name] = value;
                            onParameterValueChanged();
                        };
                    })(argumentsDict, parameterDescription.name, parameterDescription.callback)
                );
            }
            else if (parameterDescription.type == 'checkbox') {
                let input = document.createElement("input");
                input.classList.add("parameter-input");
                for (const [key, value] of Object.entries(parameterDescription)) {
                    if (key in customAttributes) {
                        continue;
                    }
                    input.setAttribute(key, value);
                }
                paramDiv.append(input);

                value = argumentsDict[parameterDescription.name];
                if (value === undefined) {
                    value = input.checked;
                    argumentsDict[parameterDescription.name] = value;
                } else {
                    input.checked = value;
                }

                input.addEventListener(
                    'change',
                    ((argumentsDict, name) => {
                        return (event) => {
                            value = event.target.checked;
                            argumentsDict[name] = value;
                            onParameterValueChanged();
                        };
                    })(argumentsDict, parameterDescription.name)
                );
            }
            else if (parameterDescription.type !== undefined) {
                let input = document.createElement("input");
                input.classList.add("parameter-input");
                // Firefox bug workaround (setting value before step corrupts the value).
                if (parameterDescription.step) {
                    input.setAttribute('step', parameterDescription.step);
                }
                for (const [key, value] of Object.entries(parameterDescription)) {
                    if (key in customAttributes) {
                        continue;
                    }
                    input.setAttribute(key, value);
                }
                paramDiv.append(input);

                value = argumentsDict[parameterDescription.name];
                if (value === undefined) {
                    value = input.value;
                    argumentsDict[parameterDescription.name] = value;
                } else {
                    input.value = value;
                }

                input.addEventListener(
                    parameterDescription.type === 'range' ? 'input' : 'change',
                    ((argumentsDict, name) => {
                        return (event) => {
                            value = event.target.value;
                            argumentsDict[name] = value;
                            onParameterValueChanged();
                        };
                    })(argumentsDict, parameterDescription.name)
                );
            }
        }
        return groupDiv;
    }

    // Init SVG
    var svg = SVG().addTo(main.querySelector(".drawing"))
        .viewbox(-width / 2, -height / 2, width, height)
        .size(width, height);

    class Side {
        // Create new instances of the same class as static attributes
        static Left = new Side(0)
        static Right = new Side(1)

        constructor(index) {
            this.index = index
        }

        opposite() {
            return (this.index == 0 ? 1 : 0);
        }
    }
    Side.prototype.valueOf = function () { return this.index; }
    Side.prototype.toString = function () { return String(this.index); }
    sides = [Side.Left, Side.Right];

    // Edge class
    class Edge {
        constructor(edgeDescription) {
            this.length = edgeLength;
            this.radius = edgeDescription.radius;
            this.angle = edgeDescription.angle;
            this.color = edgeDescription.color;
            this.originalShapeSvgGroup = svg.group();
            this.inputGeometrySvg = this.originalShapeSvgGroup
                .rect(this.length, this.radius * 2)
                .fill({ color: this.color, opacity: globals.inputGeometryFillOpacity })
                .stroke({ color: this.color, opacity: globals.inputGeometryStrokeOpacity, width: globals.inputGeometryStrokeWidth });
            this.centerLineSvg = this.originalShapeSvgGroup
                .line(0, this.radius, this.length, this.radius)
                .stroke({ color: this.color, opacity: globals.inputGeometryStrokeOpacity, width: globals.inputGeometryStrokeWidth });
            this.centerLineSvg.attr('stroke-dasharray', "4");
            this.applyTransform_();
        }

        setAngle(angle) {
            this.angle = angle % (Math.PI * 2);
            this.applyTransform_();
        }

        setRadius(radius) {
            this.radius = radius;
            this.applyTransform_();
        }

        outlinePoint(side, t) {
            return Vec2.ADD(this.outlineOrigins[side], this.outgoingDirection.scaled(t));
        }

        applyTransform_() {
            this.originalShapeSvgGroup.transform({
                origin: [0, this.radius],
                translate: [0, -this.radius],
                rotate: this.angle / Math.PI * 180,
            });
            this.outgoingDirection = new Vec2(this.length, 0).rotated(joinVertex, this.angle).normalized();
            this.outlineOrigins = [
                new Vec2(0, -this.radius).rotated(joinVertex, this.angle),
                new Vec2(0, this.radius).rotated(joinVertex, this.angle)
            ];
        }

        update_() {
            this.inputGeometrySvg.attr('fill-opacity', globals.inputGeometryFillOpacity);
            this.inputGeometrySvg.attr('stroke-opacity', globals.inputGeometryStrokeOpacity);
            this.inputGeometrySvg.attr('stroke-width', globals.inputGeometryStrokeWidth);
            this.centerLineSvg.attr('stroke-opacity', globals.inputGeometryStrokeOpacity);
            this.inputGeometrySvg.attr('stroke-width', globals.inputGeometryStrokeWidth);
        }

        clear() {
            this.originalShapeSvgGroup.clear();
        }
    }

    function onParameterValueChanged() {
        update();
    }

    function updateEdges() {

    }

    function sortByAngleAndAssignIndex(edges) {
        angleSortedEdges = [...edges].sort(function (a, b) { return a.angle - b.angle });
        for (let i = 0; i < edges.length; i++) {
            angleSortedEdges[i].index = i;
        }
        return angleSortedEdges;
    }

    function intersectRays(o0, d0, o1, d1) {
        const w = Vec2.SUBTRACT(o1, o0);
        const ddet = Vec2.DET(d0, d1);
        const ddetInv = 1 / ddet;
        const t0 = Vec2.DET(w, d1) * ddetInv;
        const t1 = Vec2.DET(w, d0) * ddetInv;
        return [t0, t1]
    }

    function computeOutlineIntersections(edges) {
        for (let e of edges) {
            e.outlineIntersections = [[], []];
        }
        for (let i = 0; i < edges.length; i++) {
            for (let j = 0; j < edges.length; j++) {
                if (i == j) {
                    continue;
                }
                let e0 = edges[i];
                let e1 = edges[j];
                [t0, t1] = intersectRays(
                    e0.outlineOrigins[Side.Right],
                    e0.outgoingDirection,
                    e1.outlineOrigins[Side.Left],
                    e1.outgoingDirection);
                if (isFinite(t0)) {
                    e0.outlineIntersections[Side.Right].push([j, t0, t1]);
                }
                if (isFinite(t1)) {
                    e1.outlineIntersections[Side.Left].push([i, t1, t0]);
                }
            }
        }
        function compareT0(a, b) { return a[1] - b[1] };
        for (let e of edges) {
            e.outlineIntersections[Side.Left].sort(compareT0);
            e.outlineIntersections[Side.Right].sort(compareT0);
        }
    }

    function drawPatchLimits(svgGroup, e) {
        for (let i = 0; i < 2; ++i) {
            let point = e.outlinePoint(i, e.tCutMax[i]);
            svgGroup
                .circle(globals.inputGeometryStrokeWidth * 2)
                .center(point.x, point.y)
                .fill({ color: e.color, opacity: globals.inputGeometryStrokeOpacity });
        }
    }

    function computePatchLimitsIndependent(svgGroup, angleSortedEdges, arguments) {
        for (let e of edges) {
            tCutMax = arguments.coefficient * e.radius;
            e.tCutMax = [
                tCutMax,
                tCutMax
            ];
            if (arguments.show) {
                drawPatchLimits(svgGroup, e);
            }
        }
    }
    var patchLimitIndependentMethod = {
        name: "Independent",
        function: computePatchLimitsIndependent,
        parameters: [
            { name: 'coefficient', prettyName: 'Coefficient', value: 2, type: 'range', min: 0, max: 10, step: 0.01 },
            { name: 'show', prettyName: 'Show', checked: true, type: 'checkbox' },
        ]
    };

    function drawExtendedOutlines(svgGroup, angleSortedEdges, arguments) {
        for (const e of angleSortedEdges) {
            for (const s of sides) {
                const outlineExtensionEndpoint = Vec2.ADD(e.outlineOrigins[s], e.outgoingDirection.scaled(-0.5 * e.length));
                svgGroup.line([e.outlineOrigins[s].asArray(), outlineExtensionEndpoint.asArray()])
                    .stroke({ color: 'black', width: globals.inputGeometryStrokeWidth }).attr('stroke-dasharray', "8 1");
            }
        }
    }

    function drawAllOutlineIntersections(svgGroup, angleSortedEdges, arguments) {
        for (const e of angleSortedEdges) {
            for (const s of sides) {
                const origin = e.outlineOrigins[s]
                const tMin = e.outlineIntersections[s][0][1]
                const tMax = e.outlineIntersections[s].slice(-1)[1]
                if (tMin < 0) {
                    const endpoint = Vec2.ADD(origin, e.outgoingDirection.scaled(tMin));
                    svgGroup.line([origin.asArray(), endpoint.asArray()])
                        .stroke({ color: e.color, opacity: globals.inputGeometryFillOpacity, width: globals.inputGeometryStrokeWidth })
                        .attr('stroke-dasharray', "8 1");
                }
                if (tMax > 0) {
                    const endpoint = Vec2.ADD(origin, e.outgoingDirection.scaled(tMax));
                    svgGroup.line([origin.asArray(), endpoint.asArray()])
                        .stroke({ color: e.color, opacity: globals.inputGeometryFillOpacity, width: globals.inputGeometryStrokeWidth })
                        .attr('stroke-dasharray', "8 1");
                }
            }
            for (intersect of e.outlineIntersections[Side.Left]) {
                const a = Vec2.ADD(e.outlineOrigins[Side.Left], e.outgoingDirection.scaled(intersect[1]));
                svgGroup.circle(5).fill({ color: e.color, opacity: 0.5 }).center(a.x, a.y);
            }
        }
    }

    // Algorithm: PerSliceIntersectCut
    // Applies to case: (extension, cut)
    //
    // Legend
    // ------------------
    // ◆: common vertex
    // ┈: center line
    // ━: outline
    // │: raw edge end
    // x: intersection
    // o: max cut point
    //
    // Sub-cases
    // ------------------
    // 	━━━┑╌╌╌x           (1)
    //     ┝━━━x━━o━━━━━━
    //  A┈┈◆┈┈┈┈┈┈┈┈┈┈┈┈B
    //
    // 	━━━┑╌╌╌╌╌╌╌╌╌x     (2)
    //     ┝━━━━━━o━━x━━━
    //  A┈┈◆┈┈┈┈┈┈┈┈┈┈┈┈B
    //
    // 	━━━━━o━━x━━━━┑     (3)
    //          x╌╌╌╌┝━━━
    //  A┈┈┈┈┈┈┈┈┈┈┈┈◆┈┈B
    //
    // 	━━x━━o━━━━━━━┑     (4)
    //    x╌╌╌╌╌╌╌╌╌╌┝━━━
    //  A┈┈┈┈┈┈┈┈┈┈┈┈◆┈┈B
    //

    function methodPerSliceIntersectCut0(svgGroup, se0, se1) {
        if (se0.isExtension && se1.isCut) {
            const e0 = se0.e;
            const e1 = se1.e;
            let p0 = e0.outlinePoint(se0.side, se0.tCutMax);
            let p1 = e1.outlinePoint(se1.side, Math.min(se1.t, se1.tCutMax));
            let p2 = p0.lerp(p1, se0.tCutMax / (se0.tCutMax + se1.tCutMax));

            // Let pX a point on [p0, p1] and [joinVertex, pX] be the segment that splits
            // the join in two halves (to have different colors).
            // We want pX to be at the orthogonal of the cut edge at the join vertex when:
            // - cut t is 0 (px == p1)
            // - the edges are colinear (px == p2)
            //
            let cutRatio = se1.isOvercut ? 1 : se1.t / se1.tCutMax;
            let pX = p1.lerp(p2, cutRatio);

            {
                let a = Vec2.ADD(joinVertex, e0.outgoingDirection.scaled(e0.length));
                let b = Vec2.ADD(e0.outlineOrigins[se0.side], e0.outgoingDirection.scaled(e0.length));
                svgGroup.polyline([a.asArray(), b.asArray(), p0.asArray(), pX.asArray(), joinVertex.asArray()])
                    .fill({ color: e0.color, opacity: 0.5 })
                    .stroke({ color: e0.color, opacity: 1.0, width: globals.inputGeometryStrokeWidth });
            }

            {
                let a = Vec2.ADD(joinVertex, e1.outgoingDirection.scaled(e1.length));
                let b = Vec2.ADD(e1.outlineOrigins[se1.side], e1.outgoingDirection.scaled(e1.length));
                svgGroup.polyline([a.asArray(), b.asArray(), p1.asArray(), pX.asArray(), joinVertex.asArray()])
                    .fill({ color: e1.color, opacity: 0.5 })
                    .stroke({ color: e1.color, opacity: 1.0, width: globals.inputGeometryStrokeWidth });
            }

            return true;
        }
        return false;
    }

    function methodPerSliceIntersectCut1(svgGroup, se0, se1) {
        if (se0.isExtension && se1.isCut) {
            const e0 = se0.e;
            const e1 = se1.e;
            let p0 = e0.outlinePoint(se0.side, se0.tCutMax);
            let p1 = e1.outlinePoint(se1.side, Math.min(se1.t, se1.tCutMax));
            let p2 = p0.lerp(p1, se0.tCutMax / (se0.tCutMax + se1.tCutMax));

            // Let pX a point on [p0, p1] and [joinVertex, pX] be the segment that splits
            // the join in two halves (to have different colors).
            // We want pX to be at the orthogonal of the cut edge at the join vertex when the edges are colinear.
            // We want pX to be p1 when:
            // - cut t < maxCut
            // - extension t is 0 (seems covered by first condition)
            let overcutRatio = se1.isOvercut ? (1 - se1.tCutMax / se1.t) : 0;
            let pX = p1.lerp(p2, overcutRatio);

            {
                let a = Vec2.ADD(joinVertex, e0.outgoingDirection.scaled(e0.length));
                let b = Vec2.ADD(e0.outlineOrigins[se0.side], e0.outgoingDirection.scaled(e0.length));
                svgGroup.polyline([a.asArray(), b.asArray(), p0.asArray(), pX.asArray(), joinVertex.asArray()])
                    .fill({ color: e0.color, opacity: 0.5 })
                    .stroke({ color: e0.color, opacity: 1.0, width: globals.inputGeometryStrokeWidth });
            }

            {
                let a = Vec2.ADD(joinVertex, e1.outgoingDirection.scaled(e1.length));
                let b = Vec2.ADD(e1.outlineOrigins[se1.side], e1.outgoingDirection.scaled(e1.length));
                svgGroup.polyline([a.asArray(), b.asArray(), p1.asArray(), pX.asArray(), joinVertex.asArray()])
                    .fill({ color: e1.color, opacity: 0.5 })
                    .stroke({ color: e1.color, opacity: 1.0, width: globals.inputGeometryStrokeWidth });
            }


            return true;
        }
        return false;
    }

    function methodPerSliceIntersectCut2(svgGroup, se0, se1) {
        if (se0.isExtension && se1.isCut) {
            const e0 = se0.e;
            const e1 = se1.e;
            let p0 = e0.outlinePoint(se0.side, se0.tCutMax);
            let p1 = e1.outlinePoint(se1.side, Math.min(se1.t, se1.tCutMax));

            // Let pX a point on [p0, p1] and [joinVertex, pX] be the segment that splits
            // the join in two halves (to have different colors).
            // We want pX to be at the orthogonal of the cut edge at the join vertex when the edges are colinear.
            // We want pX to be p1 when:
            // - cut t < maxCut
            // - extension t is 0 (seems covered by first condition)

            let p2 = p0.lerp(p1, se0.tCutMax / (se0.tCutMax + se1.tCutMax));
            let pX = p1;

            const pSplit = (e0.radius < e1.radius) ? e1.outlineOrigins[se1.side] : e0.outlineOrigins[se0.side];
            const maxRadius = Math.max(e0.radius, e1.radius)
            const ortho = Vec2.SUBTRACT(pSplit, joinVertex).normalized();
            const p1p0 = Vec2.SUBTRACT(p0, p1).normalized();
            const w = Vec2.SUBTRACT(p1, joinVertex);
            const ddet = Vec2.DET(ortho, p1p0);
            const ddetInv = 1 / ddet;
            const tOrtho = Vec2.DET(w, p1p0) * ddetInv;
            const tSlope = Vec2.DET(w, ortho) * ddetInv;

            if (e0.radius < e1.radius) {
                pX = Vec2.ADD(joinVertex, ortho.scaled(tOrtho));
                // optional
                //let cutRatio = se1.isOvercut ? 1 : se1.t / se1.tCutMax;
                //const cr = (1 - cutRatio)
                //pX = pX.lerp(p1, cr * cr);
            }
            else if (tSlope > 0 && Vec2.DOT(p1p0, e0.outgoingDirection) > 0) {
                pX = Vec2.ADD(joinVertex, ortho.scaled(tOrtho));
            }
            else {
                pX = p1;
            }

            {
                let a = Vec2.ADD(joinVertex, e0.outgoingDirection.scaled(e0.length));
                let b = Vec2.ADD(e0.outlineOrigins[se0.side], e0.outgoingDirection.scaled(e0.length));
                svgGroup.polyline([a.asArray(), b.asArray(), p0.asArray(), pX.asArray(), joinVertex.asArray()])
                    .fill({ color: e0.color, opacity: 0.5 })
                    .stroke({ color: e0.color, opacity: 1.0, width: globals.inputGeometryStrokeWidth });
            }
            {
                let a = Vec2.ADD(joinVertex, e1.outgoingDirection.scaled(e1.length));
                let b = Vec2.ADD(e1.outlineOrigins[se1.side], e1.outgoingDirection.scaled(e1.length));
                svgGroup.polyline([a.asArray(), b.asArray(), p1.asArray(), pX.asArray(), joinVertex.asArray()])
                    .fill({ color: e1.color, opacity: 0.5 })
                    .stroke({ color: e1.color, opacity: 1.0, width: globals.inputGeometryStrokeWidth });
            }

            return true;
        }
        return false;
    }

    function methodPerSliceIntersectCut3(svgGroup, se0, se1) {
        if (se0.isExtension && se1.isCut) {
            const e0 = se0.e;
            const e1 = se1.e;

            const pWide = (e0.radius < e1.radius) ? e1.outlineOrigins[se1.side] : e0.outlineOrigins[se0.side];
            const dWide = Vec2.SUBTRACT(pWide, joinVertex);

            let tp0 = Math.min(-se0.t, se0.tCutMax);
            let tp1 = Math.min(se1.t, se1.tCutMax);

            {
                const se = (e0.radius < e1.radius) ? se0 : se1;
                const e = se.e;
                const t = intersectRays(
                    e.outlineOrigins[se.side],
                    e.outgoingDirection,
                    joinVertex,
                    dWide)[0];
                if (isFinite(t)) {
                    if (e0.radius < e1.radius) {
                        tp0 = Math.min(tp0, t);
                    }
                    else {
                        tp1 = Math.min(tp1, t);
                    }
                }
            }

            let p0 = e0.outlinePoint(se0.side, tp0);
            let p1 = e1.outlinePoint(se1.side, tp1);

            let p2 = p0.lerp(p1, se0.tCutMax / (se0.tCutMax + se1.tCutMax));
            let pX = p1;

            const maxRadius = Math.max(e0.radius, e1.radius)
            const ortho = Vec2.SUBTRACT(pWide, joinVertex).normalized();
            const p1p0 = Vec2.SUBTRACT(p0, p1).normalized();
            const w = Vec2.SUBTRACT(p1, joinVertex);
            const ddet = Vec2.DET(ortho, p1p0);
            const ddetInv = 1 / ddet;
            const tOrtho = Vec2.DET(w, p1p0) * ddetInv;
            const tSlope = Vec2.DET(w, ortho) * ddetInv;

            if (e0.radius < e1.radius) {
                pX = Vec2.ADD(joinVertex, ortho.scaled(tOrtho));
                // optional
                //const cr = (1 - cutRatio)
                //pX = pX.lerp(p1, cr * cr);
            }
            else if (tSlope > 0 && Vec2.DOT(p1p0, e0.outgoingDirection) > 0) {
                pX = Vec2.ADD(joinVertex, ortho.scaled(tOrtho));
            }
            else {
                pX = p1;
            }

            {
                let a = Vec2.ADD(joinVertex, e0.outgoingDirection.scaled(e0.length));
                let b = Vec2.ADD(e0.outlineOrigins[se0.side], e0.outgoingDirection.scaled(e0.length));
                svgGroup.polyline([a.asArray(), b.asArray(), p0.asArray(), pX.asArray(), joinVertex.asArray()])
                    .fill({ color: e0.color, opacity: 0.5 })
                    .stroke({ color: e0.color, opacity: 1.0, width: globals.inputGeometryStrokeWidth });
            }
            {
                let a = Vec2.ADD(joinVertex, e1.outgoingDirection.scaled(e1.length));
                let b = Vec2.ADD(e1.outlineOrigins[se1.side], e1.outgoingDirection.scaled(e1.length));
                svgGroup.polyline([a.asArray(), b.asArray(), p1.asArray(), pX.asArray(), joinVertex.asArray()])
                    .fill({ color: e1.color, opacity: 0.5 })
                    .stroke({ color: e1.color, opacity: 1.0, width: globals.inputGeometryStrokeWidth });
            }

            return true;
        }
        return false;
    }

    function joinPerSlice(svgGroup, angleSortedEdges, arguments) {
        for (let i = 0; i < angleSortedEdges.length; ++i) {
            let j = i + 1;
            if (j >= angleSortedEdges.length) {
                j = 0;
            }
            let sliceEdges = [{ e: angleSortedEdges[i], side: Side.Right }, { e: angleSortedEdges[j], side: Side.Left }];
            let intersection = sliceEdges[0].e.outlineIntersections[Side.Right].find(function (a) { return a[0] == j; })
            if (intersection) {
                sliceEdges[0].t = intersection[1];
                sliceEdges[1].t = intersection[2];

                {
                    const e = sliceEdges[0].e;
                    const a = Vec2.ADD(e.outlineOrigins[Side.Right], e.outgoingDirection.scaled(sliceEdges[0].t));
                    svgGroup.circle(6).fill({ color: 'black' }).center(a.x, a.y);
                }

                for (let i = 0; i < 2; ++i) {
                    let se = sliceEdges[i];
                    se.tCutMax = se.e.tCutMax[se.side];
                    se.isExtension = se.t <= 0;
                    se.isCut = se.t > 0;
                    se.isOvercut = se.t > se.tCutMax;
                }

                let done = false;

                for (let i = 0; !done && i < 2; ++i) {
                    let se0 = sliceEdges[i];
                    let se1 = sliceEdges[1 - i];
                    done = methodPerSliceIntersectCut2(svgGroup, se0, se1);
                }

                if (!done) {
                    let se0 = sliceEdges[0];
                    let se1 = sliceEdges[1];
                    if (se0.isExtension && se1.isExtension) {
                        const e0 = se0.e;
                        const e1 = se1.e;
                        const pX = se0.e.outlinePoint(se0.side, se0.t);
                        {
                            let a = Vec2.ADD(joinVertex, e0.outgoingDirection.scaled(e0.length));
                            let b = Vec2.ADD(e0.outlineOrigins[se0.side], e0.outgoingDirection.scaled(e0.length));
                            svgGroup.polyline([a.asArray(), b.asArray(), pX.asArray(), joinVertex.asArray()])
                                .fill({ color: e0.color, opacity: 0.5 })
                                .stroke({ color: e0.color, opacity: 1.0, width: globals.inputGeometryStrokeWidth });
                        }
                        {
                            let a = Vec2.ADD(joinVertex, e1.outgoingDirection.scaled(e1.length));
                            let b = Vec2.ADD(e1.outlineOrigins[se1.side], e1.outgoingDirection.scaled(e1.length));
                            svgGroup.polyline([a.asArray(), b.asArray(), pX.asArray(), joinVertex.asArray()])
                                .fill({ color: e1.color, opacity: 0.5 })
                                .stroke({ color: e1.color, opacity: 1.0, width: globals.inputGeometryStrokeWidth });
                        }
                    }
                    done = true;
                }
            }
        }
    }
    var joinPerSliceMethod = {
        name: "PerSlice",
        prettyName: "Per Slice",
        function: joinPerSlice,
        parameters: [
            { name: 'dummy', prettyName: 'Dummy', value: 2, type: 'range', min: 0, max: 10, step: 0.01 },
        ]
    };

    //argumentsDict['PerSlice'].currentalgo subalgo1.coefficient

    // Scenarios
    var scenarios = [
        {
            prettyName: "2 edges of different widths",
            edges: [
                { 'radius': 15, 'angle': 0, 'color': 'blue' },
                { 'radius': 35, 'angle': 0, 'color': 'red' },
            ]
        },
        {
            prettyName: "3 edges of different widths",
            edges: [
                { 'radius': 15, 'angle': 0, 'color': 'blue' },
                { 'radius': 35, 'angle': 0, 'color': 'red' },
                { 'radius': 25, 'angle': 1, 'color': 'green' },
            ]
        },
    ];
    function setScenario(i) {
        for (e of edges) {
            e.clear();
        }
        edges = [];
        for (const edgeDescription of scenarios[i].edges) {
            edges.push(new Edge(edgeDescription));
        }
    }
    scenarioParameters = [
        { name: 'scenario', prettyName: 'Scenario', type: 'select', isTitle: 1, options: scenarios, callback: setScenario },
    ]
    parametersDiv.appendChild(createParameterGroup(scenarioParameters, globals));

    // Patch Limit Methods
    patchLimitParameters = [
        {
            name: 'patchLimitMethod', prettyName: 'Patch limit method', type: 'method', isTitle: 1, methods: [
                patchLimitIndependentMethod,
            ]
        },
    ]
    parametersDiv.appendChild(createParameterGroup(patchLimitParameters, globals));

    // Join Methods
    joinParameters = [
        {
            name: 'joinMethod', prettyName: 'Join method', type: 'method', isTitle: 1, methods: [
                drawExtendedOutlines,
                drawAllOutlineIntersections,
                joinPerSliceMethod,
            ]
        },
    ]
    parametersDiv.appendChild(createParameterGroup(joinParameters, globals));

    var edges = [];
    function init() {
        setScenario(0);
        // Draw center
        svg.circle(8).center(0, 0);
    }
    init();

    function update() {
        for (e of edges) {
            e.update_();
        }

        // common computations
        angleSortedEdges = sortByAngleAndAssignIndex(edges);
        computeOutlineIntersections(angleSortedEdges);

        resultSvgGroup.clear();

        patchLimitMethodData = globals.patchLimitMethod.methodsData[globals.patchLimitMethod.selectedMethodIndex];
        patchLimitMethodData.description.function(resultSvgGroup, angleSortedEdges, patchLimitMethodData.arguments);

        joinMethodData = globals.joinMethod.methodsData[globals.joinMethod.selectedMethodIndex];
        joinMethodData.description.function(resultSvgGroup, angleSortedEdges, joinMethodData.arguments);
    }

    var resultSvgGroup = svg.group();
    // Perform your animation here.
    // t is in milliseconds.
    //
    function animate(t) {
        // Update scenario
        edges[0].setAngle(t / 3000);
        update();
        // Return whether to stop the animation
        return false;
    }

    let start, previousTimeStamp;
    function animationLoop(timestamp) {
        if (start === undefined) {
            start = timestamp;
        }
        const elapsed = timestamp - start;
        if (previousTimeStamp !== timestamp) {
            done = animate(elapsed);
        }
        previousTimeStamp = timestamp;
        if (!done) {
            window.requestAnimationFrame(animationLoop);
        }
    }
    window.requestAnimationFrame(animationLoop);

</script>

</html>