<!DOCTYPE html>
<html>
<head>
  <title>No join</title>
  <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.0/dist/svg.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@catsums/vector2@1.2.5/lib/umd/index.min.js"></script>
</head>
<body>
<div id="drawing"></div>
</body>
</html>
<script>
    // Aliases for catsums's vector2 types
    const Vec2 = VECTOR2.Vector2;
	const Line2 = VECTOR2.Vector2Line;
	const Rect2 = VECTOR2.Rect2;
	const Transform2 = VECTOR2.Transform2;
    Vec2.prototype.isNormalized = Vec2.prototype.isNormalised

    // Global parameters.
    // We may want to turn these into HTML sliders.
    var height = 600;
    var width = 600;
    var edgeLength = 250;
    var standaloneFillOpacity = 0.5;
    var standaloneStrokeOpacity = 1;
    var standaloneStrokeWidth = 2;
    const origin = new Vec2(0, 0)

    // Init SVG
    var svg = SVG().addTo('#drawing')
        .viewbox(-width/2, -height/2, width, height)
        .size(width, height);

    // Edge class
    class Edge {
        constructor(edgeParams) {
            this.length = edgeLength;
            this.radius = edgeParams.radius;
            this.angle = edgeParams.angle;
            this.color = edgeParams.color;
            this.transformGroup = svg.group();
            this.standaloneGeometry = svg
                .rect(this.length, this.radius)
                .fill({color: this.color, opacity: standaloneFillOpacity})
                .stroke({color: this.color, opacity: standaloneStrokeOpacity, width: standaloneStrokeWidth});
            this.transformGroup.add(this.standaloneGeometry);
            this.centerLine = svg
                .line(0, this.radius/2, this.length, this.radius/2)
                .stroke({color: this.color, opacity: standaloneStrokeOpacity, width: standaloneStrokeWidth});
            this.centerLine.attr('stroke-dasharray', "4");
            this.transformGroup.add(this.centerLine);
            this.applyTransform_();
        }

        setAngle(angle) {
            this.angle = angle;
            this.applyTransform_();
        }

        setRadius(radius) {
            this.radius = radius;
            this.applyTransform_();
        }

        applyTransform_() {
            this.transformGroup.transform({
                origin: [0, this.radius/2],
                translate: [0, -this.radius/2],
                rotate: this.angle / Math.PI * 180,
            });
            this.outgoingDirection = new Vec2(this.length, 0).rotated(origin, this.angle).normalized();
            this.leftBorderOrigin = new Vec2(0, -this.radius/2).rotated(origin, this.angle);
            this.rightBorderOrigin = new Vec2(0, this.radius/2).rotated(origin, this.angle);
        }
    }

    //function intersectRays(positionA, directionA, positionB, directionB) {
        //
    //}

    // Scenario
    var scenarios = [];
    scenarios.push(
        {
            'edges': [
                { 'radius': 30, 'angle': 0, 'color': 'blue' },
                { 'radius': 70, 'angle': 0, 'color': 'red' },
            ]
        }
    );

    var edges = [];
    function init() {
        // Draw edges with initial geometry
        for (const edgeParams of scenarios[0].edges) {
            edges.push(new Edge(edgeParams));
        }

        // Draw center
        svg.circle(8).center(0, 0);
    }
    init();

    function algorithmIntersectOutlinesInEachSlice(joinContainer) {
        for (const e of edges) {
            const leftBorderExtensionTarget = Vec2.ADD(e.leftBorderOrigin, e.outgoingDirection.scaled(-0.5 * e.length));
            const rightBorderExtensionTarget = Vec2.ADD(e.rightBorderOrigin, e.outgoingDirection.scaled(-0.5 * e.length));
            joinContainer.line(
                e.leftBorderOrigin.x, e.leftBorderOrigin.y, leftBorderExtensionTarget.x, leftBorderExtensionTarget.y
            ).stroke({color: 'black', width: standaloneStrokeWidth}).attr('stroke-dasharray', "8 1");
            joinContainer.line(
                e.rightBorderOrigin.x, e.rightBorderOrigin.y, rightBorderExtensionTarget.x, rightBorderExtensionTarget.y
            ).stroke({color: 'black', width: standaloneStrokeWidth}).attr('stroke-dasharray', "8 1 4 1");
        }
    }
    var algorithms = [algorithmIntersectOutlinesInEachSlice];

    var joinContainer = svg.group();
    // Perform your animation here.
    // t is in milliseconds.
    //
    function animate(t) {

        // Update scenario
        edges[0].setAngle(t/2000);

        // TODO: compute joins, etc.
        joinContainer.clear();
        algorithms[0](joinContainer)

        // Return whether to stop the animation
        return false;
    }

    let start, previousTimeStamp;
    function animationLoop(timestamp) {
        if (start === undefined) {
            start = timestamp;
        }
        const elapsed = timestamp - start;
        if (previousTimeStamp !== timestamp) {
            done = animate(elapsed);
        }
        previousTimeStamp = timestamp;
        if (!done) {
            window.requestAnimationFrame(animationLoop);
        }
    }
    window.requestAnimationFrame(animationLoop);

</script>
