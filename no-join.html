<!DOCTYPE html>
<html>
<head>
  <title>No join</title>
  <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.0/dist/svg.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@catsums/vector2@1.2.5/lib/umd/index.min.js"></script>
  <style>.slider{width:500px;}</style>
</head>
<body>
<input class="slider" id="standaloneGeometryFillOpacity" type="range" value=0 min=0 max=1 step="0.01"/>standaloneGeometryFillOpacity<br/>
<input class="slider" id="standaloneGeometryStrokeOpacity" type="range" value=0 min=0 max=1 step="0.01"/>standaloneGeometryStrokeOpacity<br/>
<input class="slider" id="cutMaxCoefficient" type="range" value=0 min=0 max=5 step="0.01"/>cutMaxCoefficient<br/>
<input class="slider" id="edge0Angle" type="range" value=0 min=0 max=10 step="0.001"/>edge0Angle<br/>
<div id="drawing"></div>
</body>
</html>
<script>
    // Aliases for catsums's vector2 types
    const Vec2 = VECTOR2.Vector2;
	const Line2 = VECTOR2.Vector2Line;
	const Rect2 = VECTOR2.Rect2;
	const Transform2 = VECTOR2.Transform2;
    Vec2.prototype.isNormalized = Vec2.prototype.isNormalised
    Vec2.DET = function(a, b) { return a.x*b.y - a.y*b.x; }

    // Global parameters.
    // We may want to turn these into HTML sliders.
    var height = 600;
    var width = 600;
    var edgeLength = 250;
    var standaloneGeometryFillOpacity = 0.4;
    var standaloneGeometryStrokeOpacity = 0.8;
    var standaloneGeometryStrokeWidth = 2;
    var origin = new Vec2(0, 0)

    function updateEdges() {
        for (e of edges) {
            e.update_();
        }
    }

    let element = document.querySelector("#standaloneGeometryFillOpacity");
    element.addEventListener("input", (event) => {
        standaloneGeometryFillOpacity = event.target.value;
        updateEdges();
    });
    element.value = standaloneGeometryFillOpacity;

    element = document.querySelector("#standaloneGeometryStrokeOpacity");
    element.addEventListener("input", (event) => {
        standaloneGeometryStrokeOpacity = event.target.value;
        updateEdges();
    });
    element.value = standaloneGeometryStrokeOpacity;

    document.querySelector("#edge0Angle").addEventListener("input", (event) => {
        edges[0].setAngle(event.target.value);
    });

    // algorithm parameters
    var cutMaxCoefficient = 1.0;
    element = document.querySelector("#cutMaxCoefficient");
    element.addEventListener("input", (event) => {
        cutMaxCoefficient = event.target.value;
        updateEdges();
    });
    element.value = cutMaxCoefficient;

    // Init SVG
    var svg = SVG().addTo('#drawing')
        .viewbox(-width/2, -height/2, width, height)
        .size(width, height);


    class Side {
        // Create new instances of the same class as static attributes
        static Left = new Side(0)
        static Right = new Side(1)

        constructor(index) {
            this.index = index
        }

        opposite() {
            return (this.index == 0 ? 1 : 0);
        }
    }
    Side.prototype.valueOf = function(){ return this.index; }
    Side.prototype.toString = function(){ return String(this.index); }
    sides = [Side.Left, Side.Right];

    // Edge class
    class Edge {
        constructor(edgeParams) {
            this.length = edgeLength;
            this.radius = edgeParams.radius;
            this.angle = edgeParams.angle;
            this.color = edgeParams.color;
            this.transformGroup = svg.group();
            this.standaloneGeometry = this.transformGroup
                .rect(this.length, this.radius)
                .fill({color: this.color, opacity: standaloneGeometryFillOpacity})
                .stroke({color: this.color, opacity: standaloneGeometryStrokeOpacity, width: standaloneGeometryStrokeWidth});
            this.centerLine = this.transformGroup
                .line(0, this.radius/2, this.length, this.radius/2)
                .stroke({color: this.color, opacity: standaloneGeometryStrokeOpacity, width: standaloneGeometryStrokeWidth});
            this.centerLine.attr('stroke-dasharray', "4");
            this.cutMaxPoints = [
                this.transformGroup
                    .circle(5)
                    .center(cutMaxCoefficient * this.radius, 0)
                    .fill({color: this.color, opacity: standaloneGeometryStrokeOpacity}),
                this.transformGroup
                    .circle(5)
                    .center(cutMaxCoefficient * this.radius, this.radius)
                    .fill({color: this.color, opacity: standaloneGeometryStrokeOpacity})
            ];
            this.applyTransform_();
        }

        setAngle(angle) {
            this.angle = angle % (Math.PI * 2);
            this.applyTransform_();
        }

        setRadius(radius) {
            this.radius = radius;
            this.applyTransform_();
        }

        applyTransform_() {
            this.transformGroup.transform({
                origin: [0, this.radius/2],
                translate: [0, -this.radius/2],
                rotate: this.angle / Math.PI * 180,
            });
            this.outgoingDirection = new Vec2(this.length, 0).rotated(origin, this.angle).normalized();
            this.outlineOrigins = [
                new Vec2(0, -this.radius/2).rotated(origin, this.angle),
                new Vec2(0, this.radius/2).rotated(origin, this.angle)
            ];
        }

        update_() {
            this.standaloneGeometry.attr('fill-opacity', standaloneGeometryFillOpacity);
            this.standaloneGeometry.attr('stroke-opacity', standaloneGeometryStrokeOpacity);
            this.centerLine.attr('stroke-opacity', standaloneGeometryStrokeOpacity);
            this.cutMaxPoints[Side.Left]
                .center(cutMaxCoefficient * this.radius, 0)
                .fill({color: this.color, opacity: standaloneGeometryStrokeOpacity})
                .attr('fill-opacity', standaloneGeometryFillOpacity);
            this.cutMaxPoints[Side.Right]
                .center(cutMaxCoefficient * this.radius, this.radius)
                .fill({color: this.color, opacity: standaloneGeometryStrokeOpacity})
                .attr('fill-opacity', standaloneGeometryFillOpacity);
        }
    }

    //function intersectRays(positionA, directionA, positionB, directionB) {
        //
    //}

    // Scenario
    var scenarios = [];
    scenarios.push(
        {
            'edges': [
                { 'radius': 30, 'angle': 0, 'color': 'blue' },
                { 'radius': 70, 'angle': 0, 'color': 'red' },
                { 'radius': 50, 'angle': 1, 'color': 'green' },
            ]
        }
    );

    var edges = [];
    function init() {
        // Draw edges with initial geometry
        for (const edgeParams of scenarios[0].edges) {
            edges.push(new Edge(edgeParams));
        }

        // Draw center
        svg.circle(8).center(0, 0);
    }
    init();

    function sortByAngleAndAssignIndex(edges) {
        angleSortedEdges = [...edges].sort(function(a, b){return a.angle - b.angle});
        for (let i = 0; i < edges.length; i++) {
            angleSortedEdges[i].index = i;
        }
        return angleSortedEdges;
    }

    function computeOutlineIntersections(edges) {
        for (let e of edges) {
            e.outlineIntersections = [[], []];
        }
        for (let i = 0; i < edges.length; i++) {
            for (let j = 0; j < edges.length; j++) {
                if (i == j) {
                    continue;
                }
                let e0 = edges[i];
                let e1 = edges[j];
                const w = Vec2.SUBTRACT(e1.outlineOrigins[Side.Right], e0.outlineOrigins[Side.Left]);
                const ddet = Vec2.DET(e0.outgoingDirection, e1.outgoingDirection);
                const ddetInv = 1 / ddet;
                const t0 = Vec2.DET(w, e1.outgoingDirection) * ddetInv;
                const t1 = Vec2.DET(w, e0.outgoingDirection) * ddetInv;
                if (isFinite(t0)) {
                    e0.outlineIntersections[Side.Left].push([j, t0, t1]);
                }
                if (isFinite(t1)) {
                    e1.outlineIntersections[Side.Right].push([i, t1, t0]);
                }
            }
        }
        function compareT0(a, b){return a[1] - b[1]};
        for (let e of edges) {
            e.outlineIntersections[Side.Left].sort(compareT0);
            e.outlineIntersections[Side.Right].sort(compareT0);
        }
    }

    function algorithmShowExtendedOutlines(svgGroup, angleSortedEdges) {
        for (const e of angleSortedEdges) {
            for (const s of sides) {
                const outlineExtensionEndpoint = Vec2.ADD(e.outlineOrigins[s], e.outgoingDirection.scaled(-0.5 * e.length));
                svgGroup.line([e.outlineOrigins[s].asArray(), outlineExtensionEndpoint.asArray()])
                    .stroke({color: 'black', width: standaloneGeometryStrokeWidth}).attr('stroke-dasharray', "8 1");
            }
        }
    }

    function algorithmShowAllOutlineIntersections(svgGroup, angleSortedEdges) {
        for (const e of angleSortedEdges) {
            for (const s of sides) {
                const origin = e.outlineOrigins[s]
                const tMin = e.outlineIntersections[s][0][1]
                const tMax = e.outlineIntersections[s].slice(-1)[1]
                if (tMin < 0) {
                    const endpoint = Vec2.ADD(origin, e.outgoingDirection.scaled(tMin));
                    svgGroup.line([origin.asArray(), endpoint.asArray()])
                        .stroke({color: e.color, opacity: standaloneGeometryFillOpacity, width: standaloneGeometryStrokeWidth})
                        .attr('stroke-dasharray', "8 1");
                }
                if (tMax > 0) {
                    const endpoint = Vec2.ADD(origin, e.outgoingDirection.scaled(tMax));
                    svgGroup.line([origin.asArray(), endpoint.asArray()])
                        .stroke({color: e.color, opacity: standaloneGeometryFillOpacity, width: standaloneGeometryStrokeWidth})
                        .attr('stroke-dasharray', "8 1");
                }
            }
            for (intersect of e.outlineIntersections[Side.Left]) {
                const a = Vec2.ADD(e.outlineOrigins[Side.Left], e.outgoingDirection.scaled(intersect[1]));
                svgGroup.circle(5).fill({color: e.color, opacity: 0.5}).center(a.x, a.y);
            }
        }
    }

    function algorithmPerSlice0(svgGroup, angleSortedEdges) {

        for (let i = 0; i < angleSortedEdges.length; ++i) {
            let j = i + 1;
            if (j >= angleSortedEdges.length) {
                j = 0;
            }
            let e0 = angleSortedEdges[i];
            let e1 = angleSortedEdges[j];
            let intersection = e0.outlineIntersections[Side.Right].find(function(a){ return a[0] == j})
            if (intersection) {
                let t0 = intersection[1];
                let t1 = intersection[2];
                const a = Vec2.ADD(e0.outlineOrigins[Side.Right], e0.outgoingDirection.scaled(t0));
                svgGroup.circle(6).fill({color: 'black'}).center(a.x, a.y);

                const isExt0 = t0 <= 0;
                const isExt1 = t1 <= 0;
                const cutMax0 = e0.cutMaxCoefficient * e0.radius;
                const cutMax1 = e1.cutMaxCoefficient * e1.radius;

                if (isExt0 && t1 > cutMax1 && e0.radius >= e1.radius) {
                    //
                }
                else if (isExt1 && t0 > cutMax0 && e1.radius >= e0.radius) {
                    //
                }
                else {

                }

            }
            else if (Vec2.DOT(e0.outgoingDirection, e1.outgoingDirection) < 0) {
                // colinear join
            }
            else {
                // colinear overlap
            }
        }
    }

    var algorithms = [
        algorithmShowExtendedOutlines,
        algorithmShowAllOutlineIntersections,
        algorithmPerSlice0
    ];

    var resultSvgGroup = svg.group();
    // Perform your animation here.
    // t is in milliseconds.
    //
    function animate(t) {

        // Update scenario
        //edges[0].setAngle(t/3000);

        // common computations
        angleSortedEdges = sortByAngleAndAssignIndex(edges);
        computeOutlineIntersections(angleSortedEdges)

        // TODO: compute joins, etc.
        resultSvgGroup.clear();
        algorithms[1](resultSvgGroup, angleSortedEdges)

        // Return whether to stop the animation
        return false;
    }

    let start, previousTimeStamp;
    function animationLoop(timestamp) {
        if (start === undefined) {
            start = timestamp;
        }
        const elapsed = timestamp - start;
        if (previousTimeStamp !== timestamp) {
            done = animate(elapsed);
        }
        previousTimeStamp = timestamp;
        if (!done) {
            window.requestAnimationFrame(animationLoop);
        }
    }
    window.requestAnimationFrame(animationLoop);

</script>
